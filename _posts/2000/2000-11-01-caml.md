---
post_id: 2149
title: 'Le langage CAML'
date: '2000-11-01T13:35:35+01:00'

author: 'RÃ©mi Peyronnet'
layout: post
guid: '/?p=2149'
slug: caml
permalink: /2000/11/caml/
URL_before_HTML_Import: 'http://www.lprp.fr/prog/caml.php3'
image: /files/2018/11/chameau_1541286674.jpg
categories:
    - Informatique
tags:
    - OldWeb
    - Prog
lang: fr
---

Le langage CAML est un langage qui a Ã©tÃ© Ã©crit par lâ€™INRIA, et qui a pour but de se calquer exactement Ã  lâ€™Ã©criture mathÃ©matique. Pour plus de renseignements, ou pour vous procurer CAML, allez voir le site de lâ€™[INRIA](http://pauillac.inria.fr/caml/FAQ/general-fra.html)

CAML est un langage intÃ©ressant du point de vue syntaxique et surtout du point de vue des filtres, qui sont dâ€™une incroyable puissance. On y trouve aussi une gestion remarquablement pratique des listes chainÃ©es.

Le langages utilisÃ© dans le programme des classes prÃ©pa est CAML-light, langage gratuit. une version plus performante Objective-CAML existe aussi. CAML existe sur diverses plateformes. La version Windows de CAML Light ne brille pas par sa rÃ©alisation : on y trouve une fenÃªtre dâ€™exÃ©cution, dans laquelle le code et le rÃ©sultat apparaissent. La fenÃªtre directement situÃ©e en dessous est la fenÃªtre dâ€™Ã©dition du programme. Celle Ã  droite est constituÃ©e de lâ€™historique des commandes lancÃ©es, trÃ¨s pratique pour rÃ©cupÃ©rer du code accidentellement effacÃ©. Il est trÃ¨s pÃ©nible dâ€™utiliser cet Ã©diteur pour des programmes devenant consÃ©quents. Pour cela, on trouve quelques Ã©diteurs sÃ©parÃ©s, qui rendent lâ€™Ã©dition facile, et qui savent appeler CAML pour lâ€™exÃ©cution. A noter que le BlocNote et un bon copier-coller suffisent amplement !

La version Linux est nettement plus agrÃ©able. Elle fonctionne de la mÃªme faÃ§on que tous les langages traditionnels, avec lâ€™utilisation dâ€™un Ã©diteur sÃ©parÃ© (XEmacs par exemple, qui sait faire la mise en Ã©vidence de la syntaxe pour CAML), le compilateur en ligne, et lâ€™utilisation Ã©ventuelle, mais trÃ¨s agrÃ©able de lâ€™outil make.

Concernant les performances de calculs, il faut Ã©viter lâ€™idÃ©e reÃ§ue que le langage CAML est lent. Par exemple, [Objective CAML](http://www.ocaml.org) se classe de faÃ§on trÃ¨s honorable par rapport Ã  ses concurrents traditionnels dans lâ€™Ã©tude <http://www.bagley.org/~doug/shootout/craps.shtml>. Nâ€™essayez surtout pas de programmer en CAML comme vous programmeriez en C, ce nâ€™est pas du tout la mÃªme logique et vous aboutiriez forcÃ©ment Ã  des rÃ©sultats dÃ©cevants.

Les derniÃ¨res versions de CAML intÃ¨grent aussi des possibilitÃ©s dâ€™interface graphique avec GTK, de liens avec les base de donnÃ©es, et aussi de compilation en ByteCode (comme Java) recompilÃ© sur le client. Il devient alors un langage multiplateforme intÃ©ressant.

Pour tÃ©lÃ©charger CAML, vÃ©rifiez quâ€™il ne soit pas dÃ©jÃ  prÃ©sent dans votre distribution Linux, ou allez faire un tour sur le [site de lâ€™INRIA](http://www.inria.fr). Il est possible dâ€™obtenir gratuitement CAML par correspondance, en leur Ã©crivant, et joignant les timbres nÃ©cessaires.

## Rapide Initiation

Une petite initiation au CAML. Et plutÃ´t aux particularitÃ©s intÃ©ressantes de CAML.

CAML est un langage trÃ¨s typÃ©, pour lequel, variables, fonctions et procÃ©dures sont des cas particuliers de types. Ceci est trÃ¨s intÃ©ressant. Prenons un exemple : une variable entiÃ¨re sera du type int, une fonction prenant deux int et envoyant un int sera du type (int\*int)-&gt;int ou (int-&gt;int)-&gt;int. Ce deuxiÃ¨me type est plus subtile, comme vous le constaterez par la suite. Une procÃ©dure est une fonction qui ne renvoie rien, donc le type, pour une procÃ©dure qui prend un entier en paramÃ¨tre : int-&gt;unit. (unit dÃ©signant le type nul, comme void en c)

Lâ€™instruction de base est `let`. Câ€™est lui qui va permettre les affectations et les dÃ©clarations de fonctions. ` let x = 1;; ` va assigner 1 Ã  la valeur x. Les variables ont besoin dâ€™Ãªtre dÃ©clarÃ©es par let avant de pouvoir Ãªtre utilisÃ©es sans, par exemple : x = x + 1;;  
Vous avez pu constater les deux point virgules. Ils dÃ©signent la fin de la ligne. Si vous vous demandez, mais pourquoi donc *deux* point-virgulesâ€¦ et bien tout simplement parce quâ€™un seul point virgule est le dÃ©limiteur dâ€™instruction dans un bloc dâ€™instruction.

Maintenant passons Ã  lâ€™Ã©criture dâ€™une fonction. Supposons, que nous souhaitions calculer factoriel n.

```
 let rec fact = function
  | 1 -> 1;
  | n where (n>0) -> n*fact(n-1);
  | _ -> 0;;
```

Regardons un peu de plus prÃ¨s ce que signifie ce code. Tout dâ€™abord, nous reconnaissons le let de dÃ©claration. Le mot clÃ© rec insÃ©rÃ© entre let et le nom de la fonction signifie que cette fonction est dÃ©finie de maniÃ¨re rÃ©cursive. Attention il est important, sans cela, sâ€™il existe une dÃ©finition en cours de fact, les rÃ©fÃ©rences Ã  fact Ã  lâ€™intÃ©rieur de cette fonction prendrait en compte les spÃ©cifications de la fonction prÃ©cÃ©dente et non celles de la fonction en cours de dÃ©fintion. ensuite on trouve lâ€™identificateur de fonction â€˜functionâ€™. Il existe dâ€™autres mÃ©thodes Ã©quivalentes de dÃ©fintions de fonctions que nous verrons par la suite. Juste aprÃ¨s, nous voici directement en prÃ©sence de ce constitue **lâ€™**intÃ©rÃªt de CAML : jâ€™ai nommÃ© le filtrage.

En effet ces barres obliques signifient un cas de filtrage. Chaque cas de filtrage doit commencer par `|`, dire lâ€™expression correspondant au cas recherchÃ©, puis renvoyer une valeur situÃ©e aprÃ¨s `->`. La flÃ¨che `->`  veut correspondre aux notations des mathÃ©maticiens qui Ã  x associe y, en symbolisant cette phrase par `f : x -> y`. Nous retrouverons cette flÃ¨che dans dâ€™autres cas de fonctions. Un caractÃ¨re intÃ©ressant de CAML est que on nâ€™a pas eu du tout besoin de lui dire quoi que ce soit quant aux types des variables. Et pourtant, lorsque nous lanÃ§ons le programme, il affiche :

```
 fact : int -> int = fun
```

Comment a tâ€™il donc fait pour se rendre compte que nous opÃ©rions sur des entiers. Lâ€™analyseur de CAML a juste regardÃ© le code : il a vu, pour les paramÃ¨tres dâ€™entrÃ©e, que leur nombre Ã©tait reduit Ã  un, puisquâ€™il nâ€™y avait quâ€™un seul argument dans le filtrage. La premiÃ¨re ligne de filtrage contenait la valeur 1, ce qui impliquait une valeur entiÃ¨re. Pour lâ€™argument en sortie, mÃªme chose. Mais si nous supprimions la premiÃ¨re ligne du filtre, comment ferait-il ? Tout simplement en regardant les opÃ©rations faites sur ces variables. Selon les types acceptÃ©es par les fonctions utilisÃ©es, CAML est en mesure de dÃ©terminer le type des variables. Par exemple, les opÃ©rateurs +, -, \*, /, sont uniquement rÃ©servÃ©s aux entiers. Pour travailler sur des rÃ©els, il faudra utiliser, +., -., \*., /., dÃ©diÃ©s aux rÃ©els. Il est donc trÃ¨s important de bien regarder la sortie de CAML pour savoir si CAML a bien compris, et si vous nâ€™avez pas fait dâ€™erreurs, car CAML ne transige pas beaucoup avec les types incompatibles.

Pour revenir au filtrage, CAML lit les lignes de filtrages les unes aprÃ¨s les autres, et renvoie le rÃ©sultat de la premiÃ¨re ligne qui convient Ã  lâ€™entrÃ©e. Lâ€™ordre des lignes est donc capital : si nous mettions la ligne `| 1 -> 1 ;` derriÃ¨re `| n -> â€¦`, celle-ci ne serait jamais exÃ©cutÃ©e, puisque le filtrage `| n ->` convient pour 1. En effet, `| n ->` signifie de prendre le premier argument quel quâ€™il soit et de le nommer n. Sa valeur sera donc utilisable dans la suite du programme en Ã©crivant n. La clause where est trÃ¨s pratique, car elle permet de prÃ©ciser une condition supplÃ©mentaire. Il faut toutefois sâ€™en mÃ©fier, car elle nâ€™existe pas dans tous les langages CAML. (des professeurs de prÃ©pa titilleux pourraient dâ€™en offusquer, il vaut mieux prendre la prÃ©caution de mettre â€œNB : Lâ€™utilisation de where dans ce programme pourrait Ãªtre remplacÃ©e par des clauses if, mais a Ã©tÃ© conservÃ©e Ã  des fins de lisibilitÃ©.â€). Enfin le filtrage `| _ ->` correspond en quelque sorte Ã  une clause â€˜sinonâ€™, et valide nâ€™importe quelle entrÃ©e. Il est toujours prudent de mettre un tel filtre et de renvoyer un message dâ€™erreur ou une valeur montrant que les conditions des filtres prÃ©cÃ©dent nâ€™ont pas Ã©tÃ© remplies.

Voila pour notre premier programme. Examinons maintenant comment dÃ©clarer des variables dans une fonction. Cela se fait simplement par let in et where :

```
 let valA=3 and valB=4 in 
   ajoutesept x = x + valA + valB;

  ou encore

 let ajoutesept x = x + valA + valB
   where valA = 3 and valB = 4;


```

Les deux utilisations sont pratiques, selon le sens dont on a besoin. Mais pour lâ€™instant, ce sont des variables plutÃ´t constantesâ€¦ En effet, leur valeur ne peut pas Ãªtre changÃ©e par un simple valA = 4â€¦ Pour pouvoir changer, il faut faire appel aux rÃ©fÃ©rences. Les rÃ©fÃ©rences sont lâ€™appellation CAML des pointeurs des autres langages. En dÃ©finissant une rÃ©fÃ©rence vers un emplacement mÃ©moire, vous nâ€™avez pas la possibilitÃ© de modifier la rÃ©fÃ©rence, mais son contenu. Comment accÃ©der aux rÃ©fÃ©rences ? On les dÃ©clare et on les utilise simplement par

```
 
 let a = ref 0;;
 !a;;
 a:=4;;
 !a;;


```

Par ref 0, on dÃ©finit une rÃ©fÃ©rence sur 0, donc une valeur entiÃ¨re. Par !a, on accÃ¨de Ã  la valeur pointÃ©e par la rÃ©fÃ©rence. Par a:=, on modifie la valeur pointÃ©e par la rÃ©fÃ©rence. Voila, en fait câ€™est tout simple !

La derniÃ¨re chose que je ne peux taire ici est la gestion des listes sous CAML. Il faut dâ€™abord bien comprendre que les listes chaÃ®nÃ©e sont de nature rÃ©cursives, et donc seront trÃ¨s facilement utilisables par des fonctions rÃ©cursives, alors que les vecteurs (nom des tableaux en CAML, de type â€˜a vec, par exemple int vec) sont plutÃ´t utilisÃ©s dans des fonctions itÃ©ratives. Câ€™est donc tout naturellement que toutes les fonctions que nous allons crÃ©er seront rÃ©cursives.  
Une liste t::q est constituÃ© dâ€™une tÃªte t, qui contient la premiÃ¨re valeur de la liste, puis une queue q, qui contient la liste des autres Ã©lÃ©ments. si vous voulez le deuxiÃ¨me Ã©lÃ©ments de cette liste, il vous faudra prendre la tÃªte de la queue qâ€¦ Que Ã§a a lâ€™air compliquÃ© ! Mais regardons tout de suite en quoi la puissance des filtrages de CAML rend les choses aisÃ©es. Voici une fonction qui va retourner le n iÃ¨me Ã©lÃ©ment de la liste :

```
 let rec get = function
  | (t::q,0) -> t;
  | (t::q,n) -> get (q,n-1);
  | ([],n) -> failwith ("indice hors limite");
  [ _ -> faliwith ("paramÃ¨tres non valides");

let l = 1::5::8::3::[];;
get (l,2);;

```

Et si tout marche bien vous devriez obtenir 8â€¦ Le moyen de procÃ©der habituel est donc dâ€™opÃ©rer sur lâ€™Ã©lÃ©ment de la tÃªte dâ€™une liste, puis si lâ€™Ã©lÃ©ment ne convient pas, garder et opÃ©rer sur la queue de cette liste. La liste vide est \[\], la liste rÃ©duite Ã  un Ã©lÃ©ment est \[a\], ou a::\[\]. On peut dÃ©finir une liste avec a::b::c::d::\[\], ou par \[a;b;c;d\]. Cette derniÃ¨re notation est Ã  utiliser avec prÃ©cautions, car les confusions avec la dÃ©finition dâ€™un vecteur \[a,b,c,d\] sont trÃ¨s frÃ©quentesâ€¦ La fusion de deux listes se fait Ã  lâ€™aide de @. (exemple, renverser une liste avec une fonction rÃ©cursive renverse basÃ©e sur `| t::q -> renverse(q)@\[t\];` )

Voila, vous connaissez lâ€™essentiel Ã  savoir sur les listes. Toutes les fonctions sur les listes dont vous aurez besoin sont trÃ¨s facilement rÃ©alisable en quelques lignes (quelques unes dâ€™entre elles sont ci-dessous). A noter lâ€™instruction map, qui permet dâ€™appliquer une fonction Ã  tous les Ã©lÃ©ments dâ€™une liste, Ã§a pourra va servir un jour peut-Ãªtreâ€¦

Jâ€™en ai fini de cette courte prÃ©sentation de CAML, et jâ€™espÃ¨re vous avoir donnÃ© lâ€™envie dâ€™en savoir plus. Nâ€™hÃ©sitez pas Ã  regarder lâ€™aide, et de nombreux tutoriels CAML trÃ¨s bien faits (en tout cas, meilleurs que le mien ğŸ™‚ sont disponibles. Vous y dÃ©couvrirez les types, les boucles, les blocs, et les objets, pour lesquels le filtrage de CAML prend toute sa puissanceâ€¦

<a name="vrac"></a>

## Quelques programmes en vrac

Voici quelques programmes que jâ€™ai Ã©crits pendant les cours de CAML, Ã  titre dâ€™exercicesâ€¦

- [Un TD sur les listes](/files/old-web/prog/caml/td7.ml)
- [Gestion de listes ensemblistes](/files/old-web/prog/caml/tp0306.ml)
- [Un TP MIAS sur le calcul des dates](/files/old-web/prog/caml/tp_mias.ml)

*Note : Le programme â€œMini compilateur FORTHâ€ prÃ©cÃ©demment prÃ©sent sur cette page a Ã©tÃ© Ã©crit par mon professeur de CaML de lâ€™Ã©poque [Alain ChillÃ¨s](http://alain.chilles.free.fr/), et non pas par moi, comme je lâ€™ai cru quelques annÃ©es plus tard. Je lui prÃ©sente toutes mes excuses.*